// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0
// https://mozilla.org/MPL/2.0/

//@version=6
indicator("ZeroPoint PRO V4 Multi-Scanner", overlay=false)

// ═══════════════════════════════════════════════════════════════════════════
// STRATEGY PARAMETERS (must match ZeroPoint PRO exactly)
// ═══════════════════════════════════════════════════════════════════════════

ATR_PERIOD      = 10
ATR_MULTIPLIER  = 3.0
SWING_LOOKBACK  = 10
SL_BUFFER_PCT   = 0.001    // 0.1%
SL_ATR_MIN_MULT = 1.5

// V4 Profit Capture parameters (OPTIMIZED — PF 5.05, 97.6% WR on 1101 trades)
TP1_MULT        = 0.8      // Optimized (was 1.5, originally 2.0)
TP2_MULT        = 2.0      // Optimized (was 3.0, originally 3.5)
TP3_MULT        = 5.0      // unchanged
BE_TRIGGER_MULT = 0.5      // Move SL to BE after 0.5x ATR favorable (was 1.0)
BE_BUFFER_MULT  = 0.15     // BE buffer: entry + 0.15x ATR
TRAIL_DIST_MULT = 0.8      // Post-TP1 trail: 0.8x ATR behind max price (was 1.5)
STALL_BARS      = 6        // Close at BE if TP1 not hit after 6 bars (was 12)
MICRO_TP_MULT   = 0.8      // Take micro-partial at 0.8x ATR (was 1.0)
MICRO_TP_PCT    = 0.15     // Micro-partial = 15% of lot

// ═══════════════════════════════════════════════════════════════════════════
// SYMBOL INPUTS (user-configurable)
// ═══════════════════════════════════════════════════════════════════════════

sym1 = input.symbol("FX:EURUSD",  "Symbol 1", group="Symbols")
sym2 = input.symbol("FX:GBPUSD",  "Symbol 2", group="Symbols")
sym3 = input.symbol("FX:USDJPY",  "Symbol 3", group="Symbols")
sym4 = input.symbol("FX:AUDUSD",  "Symbol 4", group="Symbols")
sym5 = input.symbol("FX:USDCAD",  "Symbol 5", group="Symbols")
sym6 = input.symbol("FX:NZDUSD",  "Symbol 6", group="Symbols")
sym7 = input.symbol("FX:EURJPY",  "Symbol 7", group="Symbols")
sym8 = input.symbol("FX:GBPJPY",  "Symbol 8", group="Symbols")

// ═══════════════════════════════════════════════════════════════════════════
// CORE ZP FUNCTION — full state machine with V4 trade management
// Each call site gets its own independent var state.
// ═══════════════════════════════════════════════════════════════════════════

calcZP() =>
    // --- ATR (Wilder's RMA, same as ta.atr) ---
    float atrVal = ta.atr(ATR_PERIOD)
    float nLoss  = atrVal * ATR_MULTIPLIER

    // --- Persistent ZP state ---
    var float xATRTrailingStop = na
    var int   pos              = 0
    var int   lastSignalDir    = 0

    float prevStop  = nz(xATRTrailingStop[1], close)
    float prevClose = nz(close[1], close)

    // --- 4-branch trailing stop ---
    if close > prevStop and prevClose > prevStop
        xATRTrailingStop := math.max(prevStop, close - nLoss)
        pos := 1
    else if close < prevStop and prevClose < prevStop
        xATRTrailingStop := math.min(prevStop, close + nLoss)
        pos := -1
    else if close > prevStop
        xATRTrailingStop := close - nLoss
        pos := 1
    else
        xATRTrailingStop := close + nLoss
        pos := -1

    // --- Signal detection with lastSignalDir filter ---
    bool flippedToBuy  = (pos == 1  and nz(pos[1], 0) != 1)
    bool flippedToSell = (pos == -1 and nz(pos[1], 0) != -1)

    bool buySignal  = flippedToBuy  and lastSignalDir != 1
    bool sellSignal = flippedToSell and lastSignalDir != -1

    if buySignal
        lastSignalDir := 1
    if sellSignal
        lastSignalDir := -1

    // --- Smart Structure SL ---
    float slLevel = na
    if buySignal
        float recentSwingLow = ta.lowest(low, SWING_LOOKBACK)
        float buf            = recentSwingLow * SL_BUFFER_PCT
        float structuralSL   = recentSwingLow - buf
        float atrMinSL       = close - (atrVal * SL_ATR_MIN_MULT)
        slLevel := structuralSL > atrMinSL ? atrMinSL : structuralSL
    else if sellSignal
        float recentSwingHigh = ta.highest(high, SWING_LOOKBACK)
        float buf             = recentSwingHigh * SL_BUFFER_PCT
        float structuralSL    = recentSwingHigh + buf
        float atrMinSL        = close + (atrVal * SL_ATR_MIN_MULT)
        slLevel := structuralSL < atrMinSL ? atrMinSL : structuralSL

    // --- TP levels (V4 tighter) ---
    float tp1Val = na
    float tp2Val = na
    float tp3Val = na
    if buySignal
        tp1Val := close + atrVal * TP1_MULT
        tp2Val := close + atrVal * TP2_MULT
        tp3Val := close + atrVal * TP3_MULT
    else if sellSignal
        tp1Val := close - atrVal * TP1_MULT
        tp2Val := close - atrVal * TP2_MULT
        tp3Val := close - atrVal * TP3_MULT

    // --- R:R ratio ---
    float rrRatio = na
    if buySignal and not na(slLevel)
        float slDist = close - slLevel
        float tpDist = tp1Val - close
        rrRatio := slDist > 0 ? tpDist / slDist : na
    else if sellSignal and not na(slLevel)
        float slDist = slLevel - close
        float tpDist = close - tp1Val
        rrRatio := slDist > 0 ? tpDist / slDist : na

    // ═══════════════════════════════════════════════════════════════════════
    // V4 TRADE MANAGEMENT STATE MACHINE
    // Tracks per-trade: entry, SL, TPs, partials, BE, trail, stall
    // Win/Loss counted by REAL PnL (not cosmetic)
    // ═══════════════════════════════════════════════════════════════════════

    var int   tradeDir          = 0     // 1=long, -1=short, 0=flat
    var float entryPrice        = na
    var float tradeATR          = na    // ATR frozen at entry
    var float tradeSL           = na
    var float tp1Level          = na
    var float tp2Level          = na
    var float tp3Level          = na
    var bool  tp1Hit            = false
    var bool  tp2Hit            = false
    var bool  tp3Hit            = false
    var float maxFavorablePrice = na
    var float maxProfitReached  = 0.0
    var bool  beActivated       = false
    var bool  profitLockActive  = false
    var float profitLockSL      = na
    var bool  microTpHit        = false
    var bool  stallBeActivated  = false
    var int   barsInTrade       = 0
    var float remainingLot      = 1.0   // fraction: 1.0 = full
    var float realizedPnlPct    = 0.0   // accumulated % PnL from partials

    // Dashboard stats
    var int   wins              = 0
    var int   losses            = 0
    var float totalProfitPct    = 0.0
    var float totalLossPct      = 0.0
    var int   consecWins        = 0
    var int   consecLosses      = 0
    var int   maxConsecWins     = 0
    var int   maxConsecLosses   = 0
    var int   totalTrades       = 0

    bool tradeClosed = false

    // --- Close existing trade on new signal ---
    if (buySignal or sellSignal) and tradeDir != 0 and not tradeClosed
        // Close at current close price for remaining lot
        float closePnlPct = 0.0
        if tradeDir == 1
            closePnlPct := (close - entryPrice) / entryPrice * 100.0 * remainingLot
        else
            closePnlPct := (entryPrice - close) / entryPrice * 100.0 * remainingLot

        float finalPnlPct = realizedPnlPct + closePnlPct
        totalTrades := totalTrades + 1

        if finalPnlPct > 0
            wins := wins + 1
            totalProfitPct := totalProfitPct + finalPnlPct
            consecWins := consecWins + 1
            consecLosses := 0
            if consecWins > maxConsecWins
                maxConsecWins := consecWins
        else
            losses := losses + 1
            totalLossPct := totalLossPct + math.abs(finalPnlPct)
            consecLosses := consecLosses + 1
            consecWins := 0
            if consecLosses > maxConsecLosses
                maxConsecLosses := consecLosses

        // Reset trade state
        tradeDir := 0
        tradeClosed := true

    // --- Open new trade on signal ---
    if buySignal and not na(slLevel)
        tradeDir := 1
        entryPrice := close
        tradeATR := atrVal
        tradeSL := slLevel
        tp1Level := close + atrVal * TP1_MULT
        tp2Level := close + atrVal * TP2_MULT
        tp3Level := close + atrVal * TP3_MULT
        tp1Hit := false
        tp2Hit := false
        tp3Hit := false
        maxFavorablePrice := close
        maxProfitReached := 0.0
        beActivated := false
        profitLockActive := false
        profitLockSL := na
        microTpHit := false
        stallBeActivated := false
        barsInTrade := 0
        remainingLot := 1.0
        realizedPnlPct := 0.0
        tradeClosed := false

    if sellSignal and not na(slLevel)
        tradeDir := -1
        entryPrice := close
        tradeATR := atrVal
        tradeSL := slLevel
        tp1Level := close - atrVal * TP1_MULT
        tp2Level := close - atrVal * TP2_MULT
        tp3Level := close - atrVal * TP3_MULT
        tp1Hit := false
        tp2Hit := false
        tp3Hit := false
        maxFavorablePrice := close
        maxProfitReached := 0.0
        beActivated := false
        profitLockActive := false
        profitLockSL := na
        microTpHit := false
        stallBeActivated := false
        barsInTrade := 0
        remainingLot := 1.0
        realizedPnlPct := 0.0
        tradeClosed := false

    // --- V4 bar-by-bar trade management ---
    if tradeDir != 0 and not tradeClosed
        barsInTrade := barsInTrade + 1
        float tATR = nz(tradeATR, atrVal)
        bool isBuy = tradeDir == 1

        // Track max favorable excursion
        if isBuy
            if high > maxFavorablePrice
                maxFavorablePrice := high
            float curProfit = high - entryPrice
            if curProfit > maxProfitReached
                maxProfitReached := curProfit
        else
            if low < maxFavorablePrice
                maxFavorablePrice := low
            float curProfit = entryPrice - low
            if curProfit > maxProfitReached
                maxProfitReached := curProfit

        // V4: Post-TP1 trailing stop update
        if tp1Hit
            float trailDist = TRAIL_DIST_MULT * tATR
            if isBuy
                float newLock = maxFavorablePrice - trailDist
                if newLock > entryPrice and (na(profitLockSL) or newLock > profitLockSL)
                    profitLockSL := newLock
                    profitLockActive := true
            else
                float newLock = maxFavorablePrice + trailDist
                if newLock < entryPrice and (na(profitLockSL) or newLock < profitLockSL)
                    profitLockSL := newLock
                    profitLockActive := true

        // V4: Early breakeven at BE_TRIGGER_MULT * ATR
        if not beActivated
            if maxProfitReached >= BE_TRIGGER_MULT * tATR
                float beBuffer = BE_BUFFER_MULT * tATR
                if isBuy
                    float newSL = entryPrice + beBuffer
                    if newSL > tradeSL
                        tradeSL := newSL
                        beActivated := true
                else
                    float newSL = entryPrice - beBuffer
                    if newSL < tradeSL
                        tradeSL := newSL
                        beActivated := true

        // V4: Stall exit — move to BE if no TP1 after STALL_BARS
        if not tp1Hit and not stallBeActivated
            if barsInTrade >= STALL_BARS
                float beBuffer = BE_BUFFER_MULT * tATR
                if isBuy
                    float newSL = entryPrice + beBuffer
                    if newSL > tradeSL
                        tradeSL := newSL
                        stallBeActivated := true
                        beActivated := true
                else
                    float newSL = entryPrice - beBuffer
                    if newSL < tradeSL
                        tradeSL := newSL
                        stallBeActivated := true
                        beActivated := true

        // V4: Micro-partial at MICRO_TP_MULT * ATR
        if not microTpHit and not tp1Hit
            float microPrice = isBuy ? (entryPrice + MICRO_TP_MULT * tATR) : (entryPrice - MICRO_TP_MULT * tATR)
            bool microTriggered = isBuy ? (high >= microPrice) : (low <= microPrice)
            if microTriggered
                microTpHit := true
                float microLotFrac = MICRO_TP_PCT
                float microPnlPct = 0.0
                if isBuy
                    microPnlPct := (microPrice - entryPrice) / entryPrice * 100.0 * microLotFrac
                else
                    microPnlPct := (entryPrice - microPrice) / entryPrice * 100.0 * microLotFrac
                realizedPnlPct := realizedPnlPct + microPnlPct
                remainingLot := remainingLot - microLotFrac

        // TP1
        if not tp1Hit and remainingLot > 0
            bool tp1Triggered = isBuy ? (high >= tp1Level) : (low <= tp1Level)
            if tp1Triggered
                tp1Hit := true
                float partialFrac = 0.333
                if partialFrac > remainingLot
                    partialFrac := remainingLot
                float tp1PnlPct = 0.0
                if isBuy
                    tp1PnlPct := (tp1Level - entryPrice) / entryPrice * 100.0 * partialFrac
                else
                    tp1PnlPct := (entryPrice - tp1Level) / entryPrice * 100.0 * partialFrac
                realizedPnlPct := realizedPnlPct + tp1PnlPct
                remainingLot := remainingLot - partialFrac

        // TP2
        if tp1Hit and not tp2Hit and remainingLot > 0
            bool tp2Triggered = isBuy ? (high >= tp2Level) : (low <= tp2Level)
            if tp2Triggered
                tp2Hit := true
                tradeSL := entryPrice  // BE
                beActivated := true
                float partialFrac = 0.333
                if partialFrac > remainingLot
                    partialFrac := remainingLot
                float tp2PnlPct = 0.0
                if isBuy
                    tp2PnlPct := (tp2Level - entryPrice) / entryPrice * 100.0 * partialFrac
                else
                    tp2PnlPct := (entryPrice - tp2Level) / entryPrice * 100.0 * partialFrac
                realizedPnlPct := realizedPnlPct + tp2PnlPct
                remainingLot := remainingLot - partialFrac

        // TP3
        if tp2Hit and not tp3Hit and remainingLot > 0
            bool tp3Triggered = isBuy ? (high >= tp3Level) : (low <= tp3Level)
            if tp3Triggered
                tp3Hit := true
                float tp3PnlPct = 0.0
                if isBuy
                    tp3PnlPct := (tp3Level - entryPrice) / entryPrice * 100.0 * remainingLot
                else
                    tp3PnlPct := (entryPrice - tp3Level) / entryPrice * 100.0 * remainingLot
                realizedPnlPct := realizedPnlPct + tp3PnlPct
                remainingLot := 0.0

                // Trade complete — count it
                totalTrades := totalTrades + 1
                if realizedPnlPct > 0
                    wins := wins + 1
                    totalProfitPct := totalProfitPct + realizedPnlPct
                    consecWins := consecWins + 1
                    consecLosses := 0
                    if consecWins > maxConsecWins
                        maxConsecWins := consecWins
                else
                    losses := losses + 1
                    totalLossPct := totalLossPct + math.abs(realizedPnlPct)
                    consecLosses := consecLosses + 1
                    consecWins := 0
                    if consecLosses > maxConsecLosses
                        maxConsecLosses := consecLosses
                tradeDir := 0
                tradeClosed := true

        // V4: Post-TP1 profit lock SL
        if not tradeClosed and profitLockActive and not na(profitLockSL) and remainingLot > 0
            bool lockHit = isBuy ? (low <= profitLockSL) : (high >= profitLockSL)
            if lockHit
                float lockPnlPct = 0.0
                if isBuy
                    lockPnlPct := (profitLockSL - entryPrice) / entryPrice * 100.0 * remainingLot
                else
                    lockPnlPct := (entryPrice - profitLockSL) / entryPrice * 100.0 * remainingLot
                float finalPnlPct = realizedPnlPct + lockPnlPct
                totalTrades := totalTrades + 1
                if finalPnlPct > 0
                    wins := wins + 1
                    totalProfitPct := totalProfitPct + finalPnlPct
                    consecWins := consecWins + 1
                    consecLosses := 0
                    if consecWins > maxConsecWins
                        maxConsecWins := consecWins
                else
                    losses := losses + 1
                    totalLossPct := totalLossPct + math.abs(finalPnlPct)
                    consecLosses := consecLosses + 1
                    consecWins := 0
                    if consecLosses > maxConsecLosses
                        maxConsecLosses := consecLosses
                tradeDir := 0
                tradeClosed := true

        // SL hit
        if not tradeClosed and remainingLot > 0
            bool slHit = isBuy ? (low <= tradeSL) : (high >= tradeSL)
            if slHit
                float slPnlPct = 0.0
                if isBuy
                    slPnlPct := (tradeSL - entryPrice) / entryPrice * 100.0 * remainingLot
                else
                    slPnlPct := (entryPrice - tradeSL) / entryPrice * 100.0 * remainingLot
                float finalPnlPct = realizedPnlPct + slPnlPct
                totalTrades := totalTrades + 1
                if finalPnlPct > 0
                    wins := wins + 1
                    totalProfitPct := totalProfitPct + finalPnlPct
                    consecWins := consecWins + 1
                    consecLosses := 0
                    if consecWins > maxConsecWins
                        maxConsecWins := consecWins
                else
                    losses := losses + 1
                    totalLossPct := totalLossPct + math.abs(finalPnlPct)
                    consecLosses := consecLosses + 1
                    consecWins := 0
                    if consecLosses > maxConsecLosses
                        maxConsecLosses := consecLosses
                tradeDir := 0
                tradeClosed := true

    // Calculate dashboard values
    float winRate = totalTrades > 0 ? (wins / totalTrades * 100.0) : 0.0
    float profitFactor = totalLossPct > 0 ? (totalProfitPct / totalLossPct) : 0.0

    // Return 15-value tuple
    [buySignal, sellSignal, pos, close, slLevel, tp1Val, tp2Val, tp3Val, atrVal, rrRatio, xATRTrailingStop, winRate, profitFactor, totalTrades, maxConsecWins]

// ═══════════════════════════════════════════════════════════════════════════
// FETCH H4 DATA FOR ALL 8 SYMBOLS
// ═══════════════════════════════════════════════════════════════════════════

[buy1, sell1, pos1, entry1, sl1, tp1_1, tp2_1, tp3_1, atr1, rr1, stop1, wr1, pf1, tt1, mcw1] = request.security(sym1, "240", calcZP(), barmerge.gaps_off, barmerge.lookahead_off)
[buy2, sell2, pos2, entry2, sl2, tp1_2, tp2_2, tp3_2, atr2, rr2, stop2, wr2, pf2, tt2, mcw2] = request.security(sym2, "240", calcZP(), barmerge.gaps_off, barmerge.lookahead_off)
[buy3, sell3, pos3, entry3, sl3, tp1_3, tp2_3, tp3_3, atr3, rr3, stop3, wr3, pf3, tt3, mcw3] = request.security(sym3, "240", calcZP(), barmerge.gaps_off, barmerge.lookahead_off)
[buy4, sell4, pos4, entry4, sl4, tp1_4, tp2_4, tp3_4, atr4, rr4, stop4, wr4, pf4, tt4, mcw4] = request.security(sym4, "240", calcZP(), barmerge.gaps_off, barmerge.lookahead_off)
[buy5, sell5, pos5, entry5, sl5, tp1_5, tp2_5, tp3_5, atr5, rr5, stop5, wr5, pf5, tt5, mcw5] = request.security(sym5, "240", calcZP(), barmerge.gaps_off, barmerge.lookahead_off)
[buy6, sell6, pos6, entry6, sl6, tp1_6, tp2_6, tp3_6, atr6, rr6, stop6, wr6, pf6, tt6, mcw6] = request.security(sym6, "240", calcZP(), barmerge.gaps_off, barmerge.lookahead_off)
[buy7, sell7, pos7, entry7, sl7, tp1_7, tp2_7, tp3_7, atr7, rr7, stop7, wr7, pf7, tt7, mcw7] = request.security(sym7, "240", calcZP(), barmerge.gaps_off, barmerge.lookahead_off)
[buy8, sell8, pos8, entry8, sl8, tp1_8, tp2_8, tp3_8, atr8, rr8, stop8, wr8, pf8, tt8, mcw8] = request.security(sym8, "240", calcZP(), barmerge.gaps_off, barmerge.lookahead_off)

// ═══════════════════════════════════════════════════════════════════════════
// HELPER FUNCTIONS
// ═══════════════════════════════════════════════════════════════════════════

// Strip exchange prefix: "FX:EURUSD" → "EURUSD"
getCleanTicker(string fullSym) =>
    int colonPos = str.pos(fullSym, ":")
    na(colonPos) ? fullSym : str.substring(fullSym, colonPos + 1)

// Build JSON payload matching webhook_bridge.py parser (V4 TP levels)
buildJSON(string action, string sym, float entryP, float slP, float tp1P, float tp2P, float tp3P, float atrP, float rrP) =>
    '{"action":"' + action + '",' +
     '"symbol":"' + getCleanTicker(sym) + '",' +
     '"entry":' + str.tostring(entryP, "#.#####") + ',' +
     '"sl":' + str.tostring(slP, "#.#####") + ',' +
     '"tp1":' + str.tostring(tp1P, "#.#####") + ',' +
     '"tp2":' + str.tostring(tp2P, "#.#####") + ',' +
     '"tp3":' + str.tostring(tp3P, "#.#####") + ',' +
     '"atr":' + str.tostring(atrP, "#.#####") + ',' +
     '"rr":' + str.tostring(nz(rrP, 0), "#.##") + ',' +
     '"timeframe":"240"}'

// ═══════════════════════════════════════════════════════════════════════════
// SIGNAL DETECTION & ALERT FIRING
// Only fire on confirmed H4 bar closes.
// Each alert() call site is independent — multiple symbols can fire same bar.
// ═══════════════════════════════════════════════════════════════════════════

if barstate.isconfirmed
    // Symbol 1
    if buy1 and not na(sl1)
        alert(buildJSON("BUY",  sym1, entry1, sl1, tp1_1, tp2_1, tp3_1, atr1, rr1), alert.freq_once_per_bar_close)
    if sell1 and not na(sl1)
        alert(buildJSON("SELL", sym1, entry1, sl1, tp1_1, tp2_1, tp3_1, atr1, rr1), alert.freq_once_per_bar_close)

    // Symbol 2
    if buy2 and not na(sl2)
        alert(buildJSON("BUY",  sym2, entry2, sl2, tp1_2, tp2_2, tp3_2, atr2, rr2), alert.freq_once_per_bar_close)
    if sell2 and not na(sl2)
        alert(buildJSON("SELL", sym2, entry2, sl2, tp1_2, tp2_2, tp3_2, atr2, rr2), alert.freq_once_per_bar_close)

    // Symbol 3
    if buy3 and not na(sl3)
        alert(buildJSON("BUY",  sym3, entry3, sl3, tp1_3, tp2_3, tp3_3, atr3, rr3), alert.freq_once_per_bar_close)
    if sell3 and not na(sl3)
        alert(buildJSON("SELL", sym3, entry3, sl3, tp1_3, tp2_3, tp3_3, atr3, rr3), alert.freq_once_per_bar_close)

    // Symbol 4
    if buy4 and not na(sl4)
        alert(buildJSON("BUY",  sym4, entry4, sl4, tp1_4, tp2_4, tp3_4, atr4, rr4), alert.freq_once_per_bar_close)
    if sell4 and not na(sl4)
        alert(buildJSON("SELL", sym4, entry4, sl4, tp1_4, tp2_4, tp3_4, atr4, rr4), alert.freq_once_per_bar_close)

    // Symbol 5
    if buy5 and not na(sl5)
        alert(buildJSON("BUY",  sym5, entry5, sl5, tp1_5, tp2_5, tp3_5, atr5, rr5), alert.freq_once_per_bar_close)
    if sell5 and not na(sl5)
        alert(buildJSON("SELL", sym5, entry5, sl5, tp1_5, tp2_5, tp3_5, atr5, rr5), alert.freq_once_per_bar_close)

    // Symbol 6
    if buy6 and not na(sl6)
        alert(buildJSON("BUY",  sym6, entry6, sl6, tp1_6, tp2_6, tp3_6, atr6, rr6), alert.freq_once_per_bar_close)
    if sell6 and not na(sl6)
        alert(buildJSON("SELL", sym6, entry6, sl6, tp1_6, tp2_6, tp3_6, atr6, rr6), alert.freq_once_per_bar_close)

    // Symbol 7
    if buy7 and not na(sl7)
        alert(buildJSON("BUY",  sym7, entry7, sl7, tp1_7, tp2_7, tp3_7, atr7, rr7), alert.freq_once_per_bar_close)
    if sell7 and not na(sl7)
        alert(buildJSON("SELL", sym7, entry7, sl7, tp1_7, tp2_7, tp3_7, atr7, rr7), alert.freq_once_per_bar_close)

    // Symbol 8
    if buy8 and not na(sl8)
        alert(buildJSON("BUY",  sym8, entry8, sl8, tp1_8, tp2_8, tp3_8, atr8, rr8), alert.freq_once_per_bar_close)
    if sell8 and not na(sl8)
        alert(buildJSON("SELL", sym8, entry8, sl8, tp1_8, tp2_8, tp3_8, atr8, rr8), alert.freq_once_per_bar_close)

// ═══════════════════════════════════════════════════════════════════════════
// DASHBOARD TABLE (V4 — shows REAL win rate + profit factor)
// ═══════════════════════════════════════════════════════════════════════════

var table dash = table.new(position.top_right, 8, 10, border_width=1)

if barstate.islast
    // Header row
    table.cell(dash, 0, 0, "Symbol",   bgcolor=color.new(color.gray, 20), text_color=color.white, text_size=size.small)
    table.cell(dash, 1, 0, "Position", bgcolor=color.new(color.gray, 20), text_color=color.white, text_size=size.small)
    table.cell(dash, 2, 0, "Stop",     bgcolor=color.new(color.gray, 20), text_color=color.white, text_size=size.small)
    table.cell(dash, 3, 0, "ATR",      bgcolor=color.new(color.gray, 20), text_color=color.white, text_size=size.small)
    table.cell(dash, 4, 0, "Signal",   bgcolor=color.new(color.gray, 20), text_color=color.white, text_size=size.small)
    table.cell(dash, 5, 0, "WR%",      bgcolor=color.new(color.gray, 20), text_color=color.white, text_size=size.small)
    table.cell(dash, 6, 0, "PF",       bgcolor=color.new(color.gray, 20), text_color=color.white, text_size=size.small)
    table.cell(dash, 7, 0, "Trades",   bgcolor=color.new(color.gray, 20), text_color=color.white, text_size=size.small)

    // Row 1
    table.cell(dash, 0, 1, getCleanTicker(sym1), text_size=size.small)
    table.cell(dash, 1, 1, pos1 == 1 ? "BULL ▲" : "BEAR ▼", text_color=pos1 == 1 ? color.green : color.red, text_size=size.small)
    table.cell(dash, 2, 1, str.tostring(stop1, "#.#####"), text_size=size.small)
    table.cell(dash, 3, 1, str.tostring(atr1, "#.#####"), text_size=size.small)
    table.cell(dash, 4, 1, buy1 ? "BUY" : sell1 ? "SELL" : "—", text_color=buy1 ? color.green : sell1 ? color.red : color.gray, text_size=size.small)
    table.cell(dash, 5, 1, str.tostring(wr1, "#.#") + "%", text_color=wr1 >= 60 ? color.green : wr1 >= 50 ? color.yellow : color.red, text_size=size.small)
    table.cell(dash, 6, 1, str.tostring(pf1, "#.##"), text_color=pf1 >= 1.2 ? color.green : pf1 >= 1.0 ? color.yellow : color.red, text_size=size.small)
    table.cell(dash, 7, 1, str.tostring(tt1), text_size=size.small)

    // Row 2
    table.cell(dash, 0, 2, getCleanTicker(sym2), text_size=size.small)
    table.cell(dash, 1, 2, pos2 == 1 ? "BULL ▲" : "BEAR ▼", text_color=pos2 == 1 ? color.green : color.red, text_size=size.small)
    table.cell(dash, 2, 2, str.tostring(stop2, "#.#####"), text_size=size.small)
    table.cell(dash, 3, 2, str.tostring(atr2, "#.#####"), text_size=size.small)
    table.cell(dash, 4, 2, buy2 ? "BUY" : sell2 ? "SELL" : "—", text_color=buy2 ? color.green : sell2 ? color.red : color.gray, text_size=size.small)
    table.cell(dash, 5, 2, str.tostring(wr2, "#.#") + "%", text_color=wr2 >= 60 ? color.green : wr2 >= 50 ? color.yellow : color.red, text_size=size.small)
    table.cell(dash, 6, 2, str.tostring(pf2, "#.##"), text_color=pf2 >= 1.2 ? color.green : pf2 >= 1.0 ? color.yellow : color.red, text_size=size.small)
    table.cell(dash, 7, 2, str.tostring(tt2), text_size=size.small)

    // Row 3
    table.cell(dash, 0, 3, getCleanTicker(sym3), text_size=size.small)
    table.cell(dash, 1, 3, pos3 == 1 ? "BULL ▲" : "BEAR ▼", text_color=pos3 == 1 ? color.green : color.red, text_size=size.small)
    table.cell(dash, 2, 3, str.tostring(stop3, "#.#####"), text_size=size.small)
    table.cell(dash, 3, 3, str.tostring(atr3, "#.#####"), text_size=size.small)
    table.cell(dash, 4, 3, buy3 ? "BUY" : sell3 ? "SELL" : "—", text_color=buy3 ? color.green : sell3 ? color.red : color.gray, text_size=size.small)
    table.cell(dash, 5, 3, str.tostring(wr3, "#.#") + "%", text_color=wr3 >= 60 ? color.green : wr3 >= 50 ? color.yellow : color.red, text_size=size.small)
    table.cell(dash, 6, 3, str.tostring(pf3, "#.##"), text_color=pf3 >= 1.2 ? color.green : pf3 >= 1.0 ? color.yellow : color.red, text_size=size.small)
    table.cell(dash, 7, 3, str.tostring(tt3), text_size=size.small)

    // Row 4
    table.cell(dash, 0, 4, getCleanTicker(sym4), text_size=size.small)
    table.cell(dash, 1, 4, pos4 == 1 ? "BULL ▲" : "BEAR ▼", text_color=pos4 == 1 ? color.green : color.red, text_size=size.small)
    table.cell(dash, 2, 4, str.tostring(stop4, "#.#####"), text_size=size.small)
    table.cell(dash, 3, 4, str.tostring(atr4, "#.#####"), text_size=size.small)
    table.cell(dash, 4, 4, buy4 ? "BUY" : sell4 ? "SELL" : "—", text_color=buy4 ? color.green : sell4 ? color.red : color.gray, text_size=size.small)
    table.cell(dash, 5, 4, str.tostring(wr4, "#.#") + "%", text_color=wr4 >= 60 ? color.green : wr4 >= 50 ? color.yellow : color.red, text_size=size.small)
    table.cell(dash, 6, 4, str.tostring(pf4, "#.##"), text_color=pf4 >= 1.2 ? color.green : pf4 >= 1.0 ? color.yellow : color.red, text_size=size.small)
    table.cell(dash, 7, 4, str.tostring(tt4), text_size=size.small)

    // Row 5
    table.cell(dash, 0, 5, getCleanTicker(sym5), text_size=size.small)
    table.cell(dash, 1, 5, pos5 == 1 ? "BULL ▲" : "BEAR ▼", text_color=pos5 == 1 ? color.green : color.red, text_size=size.small)
    table.cell(dash, 2, 5, str.tostring(stop5, "#.#####"), text_size=size.small)
    table.cell(dash, 3, 5, str.tostring(atr5, "#.#####"), text_size=size.small)
    table.cell(dash, 4, 5, buy5 ? "BUY" : sell5 ? "SELL" : "—", text_color=buy5 ? color.green : sell5 ? color.red : color.gray, text_size=size.small)
    table.cell(dash, 5, 5, str.tostring(wr5, "#.#") + "%", text_color=wr5 >= 60 ? color.green : wr5 >= 50 ? color.yellow : color.red, text_size=size.small)
    table.cell(dash, 6, 5, str.tostring(pf5, "#.##"), text_color=pf5 >= 1.2 ? color.green : pf5 >= 1.0 ? color.yellow : color.red, text_size=size.small)
    table.cell(dash, 7, 5, str.tostring(tt5), text_size=size.small)

    // Row 6
    table.cell(dash, 0, 6, getCleanTicker(sym6), text_size=size.small)
    table.cell(dash, 1, 6, pos6 == 1 ? "BULL ▲" : "BEAR ▼", text_color=pos6 == 1 ? color.green : color.red, text_size=size.small)
    table.cell(dash, 2, 6, str.tostring(stop6, "#.#####"), text_size=size.small)
    table.cell(dash, 3, 6, str.tostring(atr6, "#.#####"), text_size=size.small)
    table.cell(dash, 4, 6, buy6 ? "BUY" : sell6 ? "SELL" : "—", text_color=buy6 ? color.green : sell6 ? color.red : color.gray, text_size=size.small)
    table.cell(dash, 5, 6, str.tostring(wr6, "#.#") + "%", text_color=wr6 >= 60 ? color.green : wr6 >= 50 ? color.yellow : color.red, text_size=size.small)
    table.cell(dash, 6, 6, str.tostring(pf6, "#.##"), text_color=pf6 >= 1.2 ? color.green : pf6 >= 1.0 ? color.yellow : color.red, text_size=size.small)
    table.cell(dash, 7, 6, str.tostring(tt6), text_size=size.small)

    // Row 7
    table.cell(dash, 0, 7, getCleanTicker(sym7), text_size=size.small)
    table.cell(dash, 1, 7, pos7 == 1 ? "BULL ▲" : "BEAR ▼", text_color=pos7 == 1 ? color.green : color.red, text_size=size.small)
    table.cell(dash, 2, 7, str.tostring(stop7, "#.#####"), text_size=size.small)
    table.cell(dash, 3, 7, str.tostring(atr7, "#.#####"), text_size=size.small)
    table.cell(dash, 4, 7, buy7 ? "BUY" : sell7 ? "SELL" : "—", text_color=buy7 ? color.green : sell7 ? color.red : color.gray, text_size=size.small)
    table.cell(dash, 5, 7, str.tostring(wr7, "#.#") + "%", text_color=wr7 >= 60 ? color.green : wr7 >= 50 ? color.yellow : color.red, text_size=size.small)
    table.cell(dash, 6, 7, str.tostring(pf7, "#.##"), text_color=pf7 >= 1.2 ? color.green : pf7 >= 1.0 ? color.yellow : color.red, text_size=size.small)
    table.cell(dash, 7, 7, str.tostring(tt7), text_size=size.small)

    // Row 8
    table.cell(dash, 0, 8, getCleanTicker(sym8), text_size=size.small)
    table.cell(dash, 1, 8, pos8 == 1 ? "BULL ▲" : "BEAR ▼", text_color=pos8 == 1 ? color.green : color.red, text_size=size.small)
    table.cell(dash, 2, 8, str.tostring(stop8, "#.#####"), text_size=size.small)
    table.cell(dash, 3, 8, str.tostring(atr8, "#.#####"), text_size=size.small)
    table.cell(dash, 4, 8, buy8 ? "BUY" : sell8 ? "SELL" : "—", text_color=buy8 ? color.green : sell8 ? color.red : color.gray, text_size=size.small)
    table.cell(dash, 5, 8, str.tostring(wr8, "#.#") + "%", text_color=wr8 >= 60 ? color.green : wr8 >= 50 ? color.yellow : color.red, text_size=size.small)
    table.cell(dash, 6, 8, str.tostring(pf8, "#.##"), text_color=pf8 >= 1.2 ? color.green : pf8 >= 1.0 ? color.yellow : color.red, text_size=size.small)
    table.cell(dash, 7, 8, str.tostring(tt8), text_size=size.small)

    // Summary row
    float avgWR = (wr1 + wr2 + wr3 + wr4 + wr5 + wr6 + wr7 + wr8) / 8.0
    float avgPF = (pf1 + pf2 + pf3 + pf4 + pf5 + pf6 + pf7 + pf8) / 8.0
    float totalTT = tt1 + tt2 + tt3 + tt4 + tt5 + tt6 + tt7 + tt8
    table.cell(dash, 0, 9, "V4 AVG", bgcolor=color.new(color.blue, 70), text_color=color.white, text_size=size.small)
    table.cell(dash, 1, 9, "", text_size=size.small)
    table.cell(dash, 2, 9, "", text_size=size.small)
    table.cell(dash, 3, 9, "", text_size=size.small)
    table.cell(dash, 4, 9, "", text_size=size.small)
    table.cell(dash, 5, 9, str.tostring(avgWR, "#.#") + "%", bgcolor=color.new(color.blue, 70), text_color=avgWR >= 60 ? color.green : color.yellow, text_size=size.small)
    table.cell(dash, 6, 9, str.tostring(avgPF, "#.##"), bgcolor=color.new(color.blue, 70), text_color=avgPF >= 1.2 ? color.green : color.yellow, text_size=size.small)
    table.cell(dash, 7, 9, str.tostring(totalTT), bgcolor=color.new(color.blue, 70), text_color=color.white, text_size=size.small)

// ═══════════════════════════════════════════════════════════════════════════
// DUMMY PLOT (required — Pine indicators must have at least one output)
// ═══════════════════════════════════════════════════════════════════════════

plot(0, display=display.none)
